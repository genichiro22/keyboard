   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.sync_recv,"ax",@progbits
  12               	sync_recv:
  13               	.LFB16:
  14               		.file 1 "drivers/avr/serial.c"
   1:drivers/avr/serial.c **** /*
   2:drivers/avr/serial.c ****  * WARNING: be careful changing this code, it is very timing dependent
   3:drivers/avr/serial.c ****  *
   4:drivers/avr/serial.c ****  * 2018-10-28 checked
   5:drivers/avr/serial.c ****  *  avr-gcc 4.9.2
   6:drivers/avr/serial.c ****  *  avr-gcc 5.4.0
   7:drivers/avr/serial.c ****  *  avr-gcc 7.3.0
   8:drivers/avr/serial.c ****  */
   9:drivers/avr/serial.c **** 
  10:drivers/avr/serial.c **** #ifndef F_CPU
  11:drivers/avr/serial.c **** #    define F_CPU 16000000
  12:drivers/avr/serial.c **** #endif
  13:drivers/avr/serial.c **** 
  14:drivers/avr/serial.c **** #include <avr/io.h>
  15:drivers/avr/serial.c **** #include <avr/interrupt.h>
  16:drivers/avr/serial.c **** #include <util/delay.h>
  17:drivers/avr/serial.c **** #include <stddef.h>
  18:drivers/avr/serial.c **** #include <stdbool.h>
  19:drivers/avr/serial.c **** #include "serial.h"
  20:drivers/avr/serial.c **** 
  21:drivers/avr/serial.c **** #ifdef SOFT_SERIAL_PIN
  22:drivers/avr/serial.c **** 
  23:drivers/avr/serial.c **** #    if !(defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__) || defined(__AVR_AT90USB1286__
  24:drivers/avr/serial.c **** #        error serial.c is not supported for the currently selected MCU
  25:drivers/avr/serial.c **** #    endif
  26:drivers/avr/serial.c **** // if using ATmega32U4/2, AT90USBxxx I2C, can not use PD0 and PD1 in soft serial.
  27:drivers/avr/serial.c **** #    if defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) || defined(__AVR_AT90USB646__) |
  28:drivers/avr/serial.c **** #        if defined(USE_AVR_I2C) && (SOFT_SERIAL_PIN == D0 || SOFT_SERIAL_PIN == D1)
  29:drivers/avr/serial.c **** #            error Using I2C, so can not use PD0, PD1
  30:drivers/avr/serial.c **** #        endif
  31:drivers/avr/serial.c **** #    endif
  32:drivers/avr/serial.c **** // PD0..PD3, common config
  33:drivers/avr/serial.c **** #    if SOFT_SERIAL_PIN == D0
  34:drivers/avr/serial.c **** #        define EIMSK_BIT _BV(INT0)
  35:drivers/avr/serial.c **** #        define EICRx_BIT (~(_BV(ISC00) | _BV(ISC01)))
  36:drivers/avr/serial.c **** #        define SERIAL_PIN_INTERRUPT INT0_vect
  37:drivers/avr/serial.c **** #        define EICRx EICRA
  38:drivers/avr/serial.c **** #    elif SOFT_SERIAL_PIN == D1
  39:drivers/avr/serial.c **** #        define EIMSK_BIT _BV(INT1)
  40:drivers/avr/serial.c **** #        define EICRx_BIT (~(_BV(ISC10) | _BV(ISC11)))
  41:drivers/avr/serial.c **** #        define SERIAL_PIN_INTERRUPT INT1_vect
  42:drivers/avr/serial.c **** #        define EICRx EICRA
  43:drivers/avr/serial.c **** #    elif SOFT_SERIAL_PIN == D2
  44:drivers/avr/serial.c **** #        define EIMSK_BIT _BV(INT2)
  45:drivers/avr/serial.c **** #        define EICRx_BIT (~(_BV(ISC20) | _BV(ISC21)))
  46:drivers/avr/serial.c **** #        define SERIAL_PIN_INTERRUPT INT2_vect
  47:drivers/avr/serial.c **** #        define EICRx EICRA
  48:drivers/avr/serial.c **** #    elif SOFT_SERIAL_PIN == D3
  49:drivers/avr/serial.c **** #        define EIMSK_BIT _BV(INT3)
  50:drivers/avr/serial.c **** #        define EICRx_BIT (~(_BV(ISC30) | _BV(ISC31)))
  51:drivers/avr/serial.c **** #        define SERIAL_PIN_INTERRUPT INT3_vect
  52:drivers/avr/serial.c **** #        define EICRx EICRA
  53:drivers/avr/serial.c **** #    endif
  54:drivers/avr/serial.c **** 
  55:drivers/avr/serial.c **** // ATmegaxxU2/AT90USB162 specific config
  56:drivers/avr/serial.c **** #    if defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega32U2__) || defined(__AVR_AT90USB162__)
  57:drivers/avr/serial.c **** // PD4(INT5), PD6(INT6), PD7(INT7), PC7(INT4)
  58:drivers/avr/serial.c **** #        if SOFT_SERIAL_PIN == D4
  59:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT5)
  60:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC50) | _BV(ISC51)))
  61:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT5_vect
  62:drivers/avr/serial.c **** #            define EICRx EICRB
  63:drivers/avr/serial.c **** #        elif SOFT_SERIAL_PIN == D6
  64:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT6)
  65:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC60) | _BV(ISC61)))
  66:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT6_vect
  67:drivers/avr/serial.c **** #            define EICRx EICRB
  68:drivers/avr/serial.c **** #        elif SOFT_SERIAL_PIN == D7
  69:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT7)
  70:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC70) | _BV(ISC71)))
  71:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT7_vect
  72:drivers/avr/serial.c **** #            define EICRx EICRB
  73:drivers/avr/serial.c **** #        elif SOFT_SERIAL_PIN == C7
  74:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT4)
  75:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC40) | _BV(ISC41)))
  76:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT4_vect
  77:drivers/avr/serial.c **** #            define EICRx EICRB
  78:drivers/avr/serial.c **** #        endif
  79:drivers/avr/serial.c **** #    endif
  80:drivers/avr/serial.c **** 
  81:drivers/avr/serial.c **** // ATmegaxxU4 specific config
  82:drivers/avr/serial.c **** #    if defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__)
  83:drivers/avr/serial.c **** // PE6(INT6)
  84:drivers/avr/serial.c **** #        if SOFT_SERIAL_PIN == E6
  85:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT6)
  86:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC60) | _BV(ISC61)))
  87:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT6_vect
  88:drivers/avr/serial.c **** #            define EICRx EICRB
  89:drivers/avr/serial.c **** #        endif
  90:drivers/avr/serial.c **** #    endif
  91:drivers/avr/serial.c **** 
  92:drivers/avr/serial.c **** // AT90USBxxx specific config
  93:drivers/avr/serial.c **** #    if defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__) || defined(__AVR_AT90USB1286__) 
  94:drivers/avr/serial.c **** // PE4..PE7(INT4..INT7)
  95:drivers/avr/serial.c **** #        if SOFT_SERIAL_PIN == E4
  96:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT4)
  97:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC40) | _BV(ISC41)))
  98:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT4_vect
  99:drivers/avr/serial.c **** #            define EICRx EICRB
 100:drivers/avr/serial.c **** #        elif SOFT_SERIAL_PIN == E5
 101:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT5)
 102:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC50) | _BV(ISC51)))
 103:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT5_vect
 104:drivers/avr/serial.c **** #            define EICRx EICRB
 105:drivers/avr/serial.c **** #        elif SOFT_SERIAL_PIN == E6
 106:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT6)
 107:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC60) | _BV(ISC61)))
 108:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT6_vect
 109:drivers/avr/serial.c **** #            define EICRx EICRB
 110:drivers/avr/serial.c **** #        elif SOFT_SERIAL_PIN == E7
 111:drivers/avr/serial.c **** #            define EIMSK_BIT _BV(INT7)
 112:drivers/avr/serial.c **** #            define EICRx_BIT (~(_BV(ISC70) | _BV(ISC71)))
 113:drivers/avr/serial.c **** #            define SERIAL_PIN_INTERRUPT INT7_vect
 114:drivers/avr/serial.c **** #            define EICRx EICRB
 115:drivers/avr/serial.c **** #        endif
 116:drivers/avr/serial.c **** #    endif
 117:drivers/avr/serial.c **** 
 118:drivers/avr/serial.c **** #    ifndef SERIAL_PIN_INTERRUPT
 119:drivers/avr/serial.c **** #        error invalid SOFT_SERIAL_PIN value
 120:drivers/avr/serial.c **** #    endif
 121:drivers/avr/serial.c **** 
 122:drivers/avr/serial.c **** #    define setPinInputHigh(pin) (DDRx_ADDRESS(pin) &= ~_BV((pin)&0xF), PORTx_ADDRESS(pin) |= _BV((
 123:drivers/avr/serial.c **** #    define setPinOutput(pin) (DDRx_ADDRESS(pin) |= _BV((pin)&0xF))
 124:drivers/avr/serial.c **** #    define writePinHigh(pin) (PORTx_ADDRESS(pin) |= _BV((pin)&0xF))
 125:drivers/avr/serial.c **** #    define writePinLow(pin) (PORTx_ADDRESS(pin) &= ~_BV((pin)&0xF))
 126:drivers/avr/serial.c **** #    define readPin(pin) ((bool)(PINx_ADDRESS(pin) & _BV((pin)&0xF)))
 127:drivers/avr/serial.c **** 
 128:drivers/avr/serial.c **** #    define ALWAYS_INLINE __attribute__((always_inline))
 129:drivers/avr/serial.c **** #    define NO_INLINE __attribute__((noinline))
 130:drivers/avr/serial.c **** #    define _delay_sub_us(x) __builtin_avr_delay_cycles(x)
 131:drivers/avr/serial.c **** 
 132:drivers/avr/serial.c **** // parity check
 133:drivers/avr/serial.c **** #    define ODD_PARITY 1
 134:drivers/avr/serial.c **** #    define EVEN_PARITY 0
 135:drivers/avr/serial.c **** #    define PARITY EVEN_PARITY
 136:drivers/avr/serial.c **** 
 137:drivers/avr/serial.c **** #    ifdef SERIAL_DELAY
 138:drivers/avr/serial.c **** // custom setup in config.h
 139:drivers/avr/serial.c **** // #define TID_SEND_ADJUST 2
 140:drivers/avr/serial.c **** // #define SERIAL_DELAY 6             // micro sec
 141:drivers/avr/serial.c **** // #define READ_WRITE_START_ADJUST 30 // cycles
 142:drivers/avr/serial.c **** // #define READ_WRITE_WIDTH_ADJUST 8 // cycles
 143:drivers/avr/serial.c **** #    else
 144:drivers/avr/serial.c **** // ============ Standard setups ============
 145:drivers/avr/serial.c **** 
 146:drivers/avr/serial.c **** #        ifndef SELECT_SOFT_SERIAL_SPEED
 147:drivers/avr/serial.c **** #            define SELECT_SOFT_SERIAL_SPEED 1
 148:drivers/avr/serial.c **** //  0: about 189kbps (Experimental only)
 149:drivers/avr/serial.c **** //  1: about 137kbps (default)
 150:drivers/avr/serial.c **** //  2: about 75kbps
 151:drivers/avr/serial.c **** //  3: about 39kbps
 152:drivers/avr/serial.c **** //  4: about 26kbps
 153:drivers/avr/serial.c **** //  5: about 20kbps
 154:drivers/avr/serial.c **** #        endif
 155:drivers/avr/serial.c **** 
 156:drivers/avr/serial.c **** #        if __GNUC__ < 6
 157:drivers/avr/serial.c **** #            define TID_SEND_ADJUST 14
 158:drivers/avr/serial.c **** #        else
 159:drivers/avr/serial.c **** #            define TID_SEND_ADJUST 2
 160:drivers/avr/serial.c **** #        endif
 161:drivers/avr/serial.c **** 
 162:drivers/avr/serial.c **** #        if SELECT_SOFT_SERIAL_SPEED == 0
 163:drivers/avr/serial.c **** // Very High speed
 164:drivers/avr/serial.c **** #            define SERIAL_DELAY 4  // micro sec
 165:drivers/avr/serial.c **** #            if __GNUC__ < 6
 166:drivers/avr/serial.c **** #                define READ_WRITE_START_ADJUST 33  // cycles
 167:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3   // cycles
 168:drivers/avr/serial.c **** #            else
 169:drivers/avr/serial.c **** #                define READ_WRITE_START_ADJUST 34  // cycles
 170:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7   // cycles
 171:drivers/avr/serial.c **** #            endif
 172:drivers/avr/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 1
 173:drivers/avr/serial.c **** // High speed
 174:drivers/avr/serial.c **** #            define SERIAL_DELAY 6  // micro sec
 175:drivers/avr/serial.c **** #            if __GNUC__ < 6
 176:drivers/avr/serial.c **** #                define READ_WRITE_START_ADJUST 30  // cycles
 177:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3   // cycles
 178:drivers/avr/serial.c **** #            else
 179:drivers/avr/serial.c **** #                define READ_WRITE_START_ADJUST 33  // cycles
 180:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7   // cycles
 181:drivers/avr/serial.c **** #            endif
 182:drivers/avr/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 2
 183:drivers/avr/serial.c **** // Middle speed
 184:drivers/avr/serial.c **** #            define SERIAL_DELAY 12             // micro sec
 185:drivers/avr/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 186:drivers/avr/serial.c **** #            if __GNUC__ < 6
 187:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 188:drivers/avr/serial.c **** #            else
 189:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 190:drivers/avr/serial.c **** #            endif
 191:drivers/avr/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 3
 192:drivers/avr/serial.c **** // Low speed
 193:drivers/avr/serial.c **** #            define SERIAL_DELAY 24             // micro sec
 194:drivers/avr/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 195:drivers/avr/serial.c **** #            if __GNUC__ < 6
 196:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 197:drivers/avr/serial.c **** #            else
 198:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 199:drivers/avr/serial.c **** #            endif
 200:drivers/avr/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 4
 201:drivers/avr/serial.c **** // Very Low speed
 202:drivers/avr/serial.c **** #            define SERIAL_DELAY 36             // micro sec
 203:drivers/avr/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 204:drivers/avr/serial.c **** #            if __GNUC__ < 6
 205:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 206:drivers/avr/serial.c **** #            else
 207:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 208:drivers/avr/serial.c **** #            endif
 209:drivers/avr/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 5
 210:drivers/avr/serial.c **** // Ultra Low speed
 211:drivers/avr/serial.c **** #            define SERIAL_DELAY 48             // micro sec
 212:drivers/avr/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 213:drivers/avr/serial.c **** #            if __GNUC__ < 6
 214:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 215:drivers/avr/serial.c **** #            else
 216:drivers/avr/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 217:drivers/avr/serial.c **** #            endif
 218:drivers/avr/serial.c **** #        else
 219:drivers/avr/serial.c **** #            error invalid SELECT_SOFT_SERIAL_SPEED value
 220:drivers/avr/serial.c **** #        endif /* SELECT_SOFT_SERIAL_SPEED */
 221:drivers/avr/serial.c **** #    endif     /* SERIAL_DELAY */
 222:drivers/avr/serial.c **** 
 223:drivers/avr/serial.c **** #    define SERIAL_DELAY_HALF1 (SERIAL_DELAY / 2)
 224:drivers/avr/serial.c **** #    define SERIAL_DELAY_HALF2 (SERIAL_DELAY - SERIAL_DELAY / 2)
 225:drivers/avr/serial.c **** 
 226:drivers/avr/serial.c **** #    define SLAVE_INT_WIDTH_US 1
 227:drivers/avr/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 228:drivers/avr/serial.c **** #        define SLAVE_INT_RESPONSE_TIME SERIAL_DELAY
 229:drivers/avr/serial.c **** #    else
 230:drivers/avr/serial.c **** #        define SLAVE_INT_ACK_WIDTH_UNIT 2
 231:drivers/avr/serial.c **** #        define SLAVE_INT_ACK_WIDTH 4
 232:drivers/avr/serial.c **** #    endif
 233:drivers/avr/serial.c **** 
 234:drivers/avr/serial.c **** static SSTD_t *Transaction_table      = NULL;
 235:drivers/avr/serial.c **** static uint8_t Transaction_table_size = 0;
 236:drivers/avr/serial.c **** 
 237:drivers/avr/serial.c **** inline static void serial_delay(void) ALWAYS_INLINE;
 238:drivers/avr/serial.c **** inline static void serial_delay(void) { _delay_us(SERIAL_DELAY); }
 239:drivers/avr/serial.c **** 
 240:drivers/avr/serial.c **** inline static void serial_delay_half1(void) ALWAYS_INLINE;
 241:drivers/avr/serial.c **** inline static void serial_delay_half1(void) { _delay_us(SERIAL_DELAY_HALF1); }
 242:drivers/avr/serial.c **** 
 243:drivers/avr/serial.c **** inline static void serial_delay_half2(void) ALWAYS_INLINE;
 244:drivers/avr/serial.c **** inline static void serial_delay_half2(void) { _delay_us(SERIAL_DELAY_HALF2); }
 245:drivers/avr/serial.c **** 
 246:drivers/avr/serial.c **** inline static void serial_output(void) ALWAYS_INLINE;
 247:drivers/avr/serial.c **** inline static void serial_output(void) { setPinOutput(SOFT_SERIAL_PIN); }
 248:drivers/avr/serial.c **** 
 249:drivers/avr/serial.c **** // make the serial pin an input with pull-up resistor
 250:drivers/avr/serial.c **** inline static void serial_input_with_pullup(void) ALWAYS_INLINE;
 251:drivers/avr/serial.c **** inline static void serial_input_with_pullup(void) { setPinInputHigh(SOFT_SERIAL_PIN); }
 252:drivers/avr/serial.c **** 
 253:drivers/avr/serial.c **** inline static uint8_t serial_read_pin(void) ALWAYS_INLINE;
 254:drivers/avr/serial.c **** inline static uint8_t serial_read_pin(void) { return !!readPin(SOFT_SERIAL_PIN); }
 255:drivers/avr/serial.c **** 
 256:drivers/avr/serial.c **** inline static void serial_low(void) ALWAYS_INLINE;
 257:drivers/avr/serial.c **** inline static void serial_low(void) { writePinLow(SOFT_SERIAL_PIN); }
 258:drivers/avr/serial.c **** 
 259:drivers/avr/serial.c **** inline static void serial_high(void) ALWAYS_INLINE;
 260:drivers/avr/serial.c **** inline static void serial_high(void) { writePinHigh(SOFT_SERIAL_PIN); }
 261:drivers/avr/serial.c **** 
 262:drivers/avr/serial.c **** void soft_serial_initiator_init(SSTD_t *sstd_table, int sstd_table_size) {
 263:drivers/avr/serial.c ****     Transaction_table      = sstd_table;
 264:drivers/avr/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 265:drivers/avr/serial.c ****     serial_output();
 266:drivers/avr/serial.c ****     serial_high();
 267:drivers/avr/serial.c **** }
 268:drivers/avr/serial.c **** 
 269:drivers/avr/serial.c **** void soft_serial_target_init(SSTD_t *sstd_table, int sstd_table_size) {
 270:drivers/avr/serial.c ****     Transaction_table      = sstd_table;
 271:drivers/avr/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 272:drivers/avr/serial.c ****     serial_input_with_pullup();
 273:drivers/avr/serial.c **** 
 274:drivers/avr/serial.c ****     // Enable INT0-INT7
 275:drivers/avr/serial.c ****     EIMSK |= EIMSK_BIT;
 276:drivers/avr/serial.c ****     EICRx &= EICRx_BIT;
 277:drivers/avr/serial.c **** }
 278:drivers/avr/serial.c **** 
 279:drivers/avr/serial.c **** // Used by the sender to synchronize timing with the reciver.
 280:drivers/avr/serial.c **** static void sync_recv(void) NO_INLINE;
 281:drivers/avr/serial.c **** static void sync_recv(void) {
  15               		.loc 1 281 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22               		.loc 1 281 0
  23 0000 8EE1      		ldi r24,lo8(30)
  24               	.LVL1:
  25               	.L2:
  26               	.LBB124:
 282:drivers/avr/serial.c ****     for (uint8_t i = 0; i < SERIAL_DELAY * 5 && serial_read_pin(); i++) {
  27               		.loc 1 282 0
  28 0002 4A9B      		sbis 0x9,2
  29 0004 00C0      		rjmp .L7
  30               	.LVL2:
  31 0006 8150      		subi r24,lo8(-(-1))
  32               	.LVL3:
  33               		.loc 1 282 0 is_stmt 0 discriminator 4
  34 0008 01F4      		brne .L2
  35               	.LVL4:
  36               	.L7:
  37               	.LBE124:
 283:drivers/avr/serial.c ****     }
 284:drivers/avr/serial.c ****     // This shouldn't hang if the target disconnects because the
 285:drivers/avr/serial.c ****     // serial line will float to high if the target does disconnect.
 286:drivers/avr/serial.c ****     while (!serial_read_pin())
  38               		.loc 1 286 0 is_stmt 1 discriminator 1
  39 000a 4A9B      		sbis 0x9,2
  40 000c 00C0      		rjmp .L7
  41               	/* epilogue start */
 287:drivers/avr/serial.c ****         ;
 288:drivers/avr/serial.c **** }
  42               		.loc 1 288 0
  43 000e 0895      		ret
  44               		.cfi_endproc
  45               	.LFE16:
  47               		.section	.text.sync_send,"ax",@progbits
  49               	sync_send:
  50               	.LFB17:
 289:drivers/avr/serial.c **** 
 290:drivers/avr/serial.c **** // Used by the reciver to send a synchronization signal to the sender.
 291:drivers/avr/serial.c **** static void sync_send(void) NO_INLINE;
 292:drivers/avr/serial.c **** static void sync_send(void) {
  51               		.loc 1 292 0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57               	.LBB125:
  58               	.LBB126:
 257:drivers/avr/serial.c **** 
  59               		.loc 1 257 0
  60 0000 5A98      		cbi 0xb,2
  61               	.LVL5:
  62               	.LBE126:
  63               	.LBE125:
  64               	.LBB127:
  65               	.LBB128:
  66               	.LBB129:
  67               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  68               		.loc 2 276 0
  69 0002 80E2      		ldi r24,lo8(32)
  70 0004 8A95      	1:	dec r24
  71 0006 01F4      		brne 1b
  72               	.LVL6:
  73               	.LBE129:
  74               	.LBE128:
  75               	.LBE127:
  76               	.LBB130:
  77               	.LBB131:
 260:drivers/avr/serial.c **** 
  78               		.loc 1 260 0
  79 0008 5A9A      		sbi 0xb,2
  80 000a 0895      		ret
  81               	.LBE131:
  82               	.LBE130:
  83               		.cfi_endproc
  84               	.LFE17:
  86               		.section	.text.serial_read_chunk,"ax",@progbits
  88               	serial_read_chunk:
  89               	.LFB18:
 293:drivers/avr/serial.c ****     serial_low();
 294:drivers/avr/serial.c ****     serial_delay();
 295:drivers/avr/serial.c ****     serial_high();
 296:drivers/avr/serial.c **** }
 297:drivers/avr/serial.c **** 
 298:drivers/avr/serial.c **** // Reads a byte from the serial line
 299:drivers/avr/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) NO_INLINE;
 300:drivers/avr/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) {
  90               		.loc 1 300 0
  91               		.cfi_startproc
  92               	.LVL7:
  93               	/* prologue: function */
  94               	/* frame size = 0 */
  95               	/* stack size = 0 */
  96               	.L__stack_usage = 0
  97 0000 FC01      		movw r30,r24
 301:drivers/avr/serial.c ****     uint8_t byte, i, p, pb;
 302:drivers/avr/serial.c **** 
 303:drivers/avr/serial.c ****     _delay_sub_us(READ_WRITE_START_ADJUST);
  98               		.loc 1 303 0
  99 0002 2AE0      		ldi r18,lo8(10)
 100 0004 2A95      	1:	dec r18
 101 0006 01F4      		brne 1b
 102               	.LVL8:
 304:drivers/avr/serial.c ****     for (i = 0, byte = 0, p = PARITY; i < bit; i++) {
 103               		.loc 1 304 0
 104 0008 90E0      		ldi r25,0
 105 000a 20E0      		ldi r18,0
 106 000c 80E0      		ldi r24,0
 107               	.LVL9:
 305:drivers/avr/serial.c ****         serial_delay_half1();  // read the middle of pulses
 306:drivers/avr/serial.c ****         if (serial_read_pin()) {
 307:drivers/avr/serial.c ****             byte = (byte << 1) | 1;
 308:drivers/avr/serial.c ****             p ^= 1;
 108               		.loc 1 308 0
 109 000e 31E0      		ldi r19,lo8(1)
 110               	.LVL10:
 111               	.L13:
 304:drivers/avr/serial.c ****     for (i = 0, byte = 0, p = PARITY; i < bit; i++) {
 112               		.loc 1 304 0 discriminator 1
 113 0010 2617      		cp r18,r22
 114 0012 01F0      		breq .L17
 115               	.LVL11:
 116               	.LBB132:
 117               	.LBB133:
 118               	.LBB134:
 119               		.loc 2 276 0
 120 0014 40E1      		ldi r20,lo8(16)
 121 0016 4A95      	1:	dec r20
 122 0018 01F4      		brne 1b
 123               	.LVL12:
 124               	.LBE134:
 125               	.LBE133:
 126               	.LBE132:
 307:drivers/avr/serial.c ****             p ^= 1;
 127               		.loc 1 307 0
 128 001a 880F      		lsl r24
 129               	.LVL13:
 306:drivers/avr/serial.c ****             byte = (byte << 1) | 1;
 130               		.loc 1 306 0
 131 001c 4A9B      		sbis 0x9,2
 132 001e 00C0      		rjmp .L15
 307:drivers/avr/serial.c ****             p ^= 1;
 133               		.loc 1 307 0
 134 0020 8160      		ori r24,lo8(1)
 135               	.LVL14:
 136               		.loc 1 308 0
 137 0022 9327      		eor r25,r19
 138               	.LVL15:
 139               	.L15:
 309:drivers/avr/serial.c ****         } else {
 310:drivers/avr/serial.c ****             byte = (byte << 1) | 0;
 311:drivers/avr/serial.c ****             p ^= 0;
 312:drivers/avr/serial.c ****         }
 313:drivers/avr/serial.c ****         _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 140               		.loc 1 313 0 discriminator 2
 141 0024 00C0      		rjmp .
 142 0026 0000      		nop
 143               	.LVL16:
 144               	.LBB135:
 145               	.LBB136:
 146               	.LBB137:
 147               		.loc 2 276 0 discriminator 2
 148 0028 40E1      		ldi r20,lo8(16)
 149 002a 4A95      	1:	dec r20
 150 002c 01F4      		brne 1b
 151               	.LVL17:
 152               	.LBE137:
 153               	.LBE136:
 154               	.LBE135:
 304:drivers/avr/serial.c ****         serial_delay_half1();  // read the middle of pulses
 155               		.loc 1 304 0 discriminator 2
 156 002e 2F5F      		subi r18,lo8(-(1))
 157               	.LVL18:
 158 0030 00C0      		rjmp .L13
 159               	.L17:
 160               	.LVL19:
 161               	.LBB138:
 162               	.LBB139:
 163               	.LBB140:
 164               		.loc 2 276 0
 165 0032 20E1      		ldi r18,lo8(16)
 166 0034 2A95      	1:	dec r18
 167 0036 01F4      		brne 1b
 168               	.LVL20:
 169               	.LBE140:
 170               	.LBE139:
 171               	.LBE138:
 172               	.LBB141:
 173               	.LBB142:
 254:drivers/avr/serial.c **** 
 174               		.loc 1 254 0
 175 0038 29B1      		in r18,0x9
 176               	.LBE142:
 177               	.LBE141:
 314:drivers/avr/serial.c ****         serial_delay_half2();
 315:drivers/avr/serial.c ****     }
 316:drivers/avr/serial.c ****     /* recive parity bit */
 317:drivers/avr/serial.c ****     serial_delay_half1();  // read the middle of pulses
 318:drivers/avr/serial.c ****     pb = serial_read_pin();
 319:drivers/avr/serial.c ****     _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 178               		.loc 1 319 0
 179 003a 00C0      		rjmp .
 180 003c 0000      		nop
 181               	.LVL21:
 182               	.LBB143:
 183               	.LBB144:
 184               	.LBB145:
 185               		.loc 2 276 0
 186 003e 30E1      		ldi r19,lo8(16)
 187 0040 3A95      	1:	dec r19
 188 0042 01F4      		brne 1b
 189               	.LVL22:
 190 0044 22FB      		bst r18,2
 191 0046 2227      		clr r18
 192 0048 20F9      		bld r18,0
 193 004a 9227      		eor r25,r18
 194               	.LVL23:
 195               	.LBE145:
 196               	.LBE144:
 197               	.LBE143:
 320:drivers/avr/serial.c ****     serial_delay_half2();
 321:drivers/avr/serial.c **** 
 322:drivers/avr/serial.c ****     *pterrcount += (p != pb) ? 1 : 0;
 198               		.loc 1 322 0
 199 004c 2081      		ld r18,Z
 200 004e 920F      		add r25,r18
 201 0050 9083      		st Z,r25
 323:drivers/avr/serial.c **** 
 324:drivers/avr/serial.c ****     return byte;
 325:drivers/avr/serial.c **** }
 202               		.loc 1 325 0
 203 0052 0895      		ret
 204               		.cfi_endproc
 205               	.LFE18:
 207               		.section	.text.serial_recive_packet,"ax",@progbits
 209               	serial_recive_packet:
 210               	.LFB21:
 326:drivers/avr/serial.c **** 
 327:drivers/avr/serial.c **** // Sends a byte with MSB ordering
 328:drivers/avr/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) NO_INLINE;
 329:drivers/avr/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) {
 330:drivers/avr/serial.c ****     uint8_t b, p;
 331:drivers/avr/serial.c ****     for (p = PARITY, b = 1 << (bit - 1); b; b >>= 1) {
 332:drivers/avr/serial.c ****         if (data & b) {
 333:drivers/avr/serial.c ****             serial_high();
 334:drivers/avr/serial.c ****             p ^= 1;
 335:drivers/avr/serial.c ****         } else {
 336:drivers/avr/serial.c ****             serial_low();
 337:drivers/avr/serial.c ****             p ^= 0;
 338:drivers/avr/serial.c ****         }
 339:drivers/avr/serial.c ****         serial_delay();
 340:drivers/avr/serial.c ****     }
 341:drivers/avr/serial.c ****     /* send parity bit */
 342:drivers/avr/serial.c ****     if (p & 1) {
 343:drivers/avr/serial.c ****         serial_high();
 344:drivers/avr/serial.c ****     } else {
 345:drivers/avr/serial.c ****         serial_low();
 346:drivers/avr/serial.c ****     }
 347:drivers/avr/serial.c ****     serial_delay();
 348:drivers/avr/serial.c **** 
 349:drivers/avr/serial.c ****     serial_low();  // sync_send() / senc_recv() need raise edge
 350:drivers/avr/serial.c **** }
 351:drivers/avr/serial.c **** 
 352:drivers/avr/serial.c **** static void serial_send_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 353:drivers/avr/serial.c **** static void serial_send_packet(uint8_t *buffer, uint8_t size) {
 354:drivers/avr/serial.c ****     for (uint8_t i = 0; i < size; ++i) {
 355:drivers/avr/serial.c ****         uint8_t data;
 356:drivers/avr/serial.c ****         data = buffer[i];
 357:drivers/avr/serial.c ****         sync_send();
 358:drivers/avr/serial.c ****         serial_write_chunk(data, 8);
 359:drivers/avr/serial.c ****     }
 360:drivers/avr/serial.c **** }
 361:drivers/avr/serial.c **** 
 362:drivers/avr/serial.c **** static uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 363:drivers/avr/serial.c **** static uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) {
 211               		.loc 1 363 0
 212               		.cfi_startproc
 213               	.LVL24:
 214 0000 EF92      		push r14
 215               	.LCFI0:
 216               		.cfi_def_cfa_offset 3
 217               		.cfi_offset 14, -2
 218 0002 FF92      		push r15
 219               	.LCFI1:
 220               		.cfi_def_cfa_offset 4
 221               		.cfi_offset 15, -3
 222 0004 0F93      		push r16
 223               	.LCFI2:
 224               		.cfi_def_cfa_offset 5
 225               		.cfi_offset 16, -4
 226 0006 1F93      		push r17
 227               	.LCFI3:
 228               		.cfi_def_cfa_offset 6
 229               		.cfi_offset 17, -5
 230 0008 CF93      		push r28
 231               	.LCFI4:
 232               		.cfi_def_cfa_offset 7
 233               		.cfi_offset 28, -6
 234 000a DF93      		push r29
 235               	.LCFI5:
 236               		.cfi_def_cfa_offset 8
 237               		.cfi_offset 29, -7
 238 000c 1F92      		push __zero_reg__
 239               	.LCFI6:
 240               		.cfi_def_cfa_offset 9
 241 000e CDB7      		in r28,__SP_L__
 242 0010 DEB7      		in r29,__SP_H__
 243               	.LCFI7:
 244               		.cfi_def_cfa_register 28
 245               	/* prologue: function */
 246               	/* frame size = 1 */
 247               	/* stack size = 7 */
 248               	.L__stack_usage = 7
 364:drivers/avr/serial.c ****     uint8_t pecount = 0;
 249               		.loc 1 364 0
 250 0012 1982      		std Y+1,__zero_reg__
 251               	.LVL25:
 252 0014 8C01      		movw r16,r24
 253 0016 7C01      		movw r14,r24
 254 0018 E60E      		add r14,r22
 255 001a F11C      		adc r15,__zero_reg__
 256               	.LVL26:
 257               	.L19:
 258               	.LBB146:
 365:drivers/avr/serial.c ****     for (uint8_t i = 0; i < size; ++i) {
 259               		.loc 1 365 0 discriminator 1
 260 001c 0E15      		cp r16,r14
 261 001e 1F05      		cpc r17,r15
 262 0020 01F0      		breq .L25
 263               	.LBB147:
 366:drivers/avr/serial.c ****         uint8_t data;
 367:drivers/avr/serial.c ****         sync_recv();
 264               		.loc 1 367 0 discriminator 3
 265 0022 0E94 0000 		call sync_recv
 266               	.LVL27:
 368:drivers/avr/serial.c ****         data      = serial_read_chunk(&pecount, 8);
 267               		.loc 1 368 0 discriminator 3
 268 0026 68E0      		ldi r22,lo8(8)
 269 0028 CE01      		movw r24,r28
 270 002a 0196      		adiw r24,1
 271 002c 0E94 0000 		call serial_read_chunk
 272               	.LVL28:
 369:drivers/avr/serial.c ****         buffer[i] = data;
 273               		.loc 1 369 0 discriminator 3
 274 0030 F801      		movw r30,r16
 275 0032 8193      		st Z+,r24
 276 0034 8F01      		movw r16,r30
 277               	.LVL29:
 278 0036 00C0      		rjmp .L19
 279               	.LVL30:
 280               	.L25:
 281               	.LBE147:
 282               	.LBE146:
 370:drivers/avr/serial.c ****     }
 371:drivers/avr/serial.c ****     return pecount == 0;
 283               		.loc 1 371 0
 284 0038 81E0      		ldi r24,lo8(1)
 285 003a 9981      		ldd r25,Y+1
 286 003c 9111      		cpse r25,__zero_reg__
 287 003e 80E0      		ldi r24,0
 288               	.L21:
 289               	/* epilogue start */
 372:drivers/avr/serial.c **** }
 290               		.loc 1 372 0
 291 0040 0F90      		pop __tmp_reg__
 292 0042 DF91      		pop r29
 293 0044 CF91      		pop r28
 294 0046 1F91      		pop r17
 295 0048 0F91      		pop r16
 296               	.LVL31:
 297 004a FF90      		pop r15
 298 004c EF90      		pop r14
 299 004e 0895      		ret
 300               		.cfi_endproc
 301               	.LFE21:
 303               		.section	.text.soft_serial_initiator_init,"ax",@progbits
 304               	.global	soft_serial_initiator_init
 306               	soft_serial_initiator_init:
 307               	.LFB14:
 262:drivers/avr/serial.c ****     Transaction_table      = sstd_table;
 308               		.loc 1 262 0
 309               		.cfi_startproc
 310               	.LVL32:
 311               	/* prologue: function */
 312               	/* frame size = 0 */
 313               	/* stack size = 0 */
 314               	.L__stack_usage = 0
 263:drivers/avr/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 315               		.loc 1 263 0
 316 0000 9093 0000 		sts Transaction_table+1,r25
 317 0004 8093 0000 		sts Transaction_table,r24
 264:drivers/avr/serial.c ****     serial_output();
 318               		.loc 1 264 0
 319 0008 6093 0000 		sts Transaction_table_size,r22
 320               	.LBB148:
 321               	.LBB149:
 247:drivers/avr/serial.c **** 
 322               		.loc 1 247 0
 323 000c 529A      		sbi 0xa,2
 324               	.LBE149:
 325               	.LBE148:
 326               	.LBB150:
 327               	.LBB151:
 260:drivers/avr/serial.c **** 
 328               		.loc 1 260 0
 329 000e 5A9A      		sbi 0xb,2
 330 0010 0895      		ret
 331               	.LBE151:
 332               	.LBE150:
 333               		.cfi_endproc
 334               	.LFE14:
 336               		.section	.text.soft_serial_target_init,"ax",@progbits
 337               	.global	soft_serial_target_init
 339               	soft_serial_target_init:
 340               	.LFB15:
 269:drivers/avr/serial.c ****     Transaction_table      = sstd_table;
 341               		.loc 1 269 0
 342               		.cfi_startproc
 343               	.LVL33:
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 346               	/* stack size = 0 */
 347               	.L__stack_usage = 0
 270:drivers/avr/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 348               		.loc 1 270 0
 349 0000 9093 0000 		sts Transaction_table+1,r25
 350 0004 8093 0000 		sts Transaction_table,r24
 271:drivers/avr/serial.c ****     serial_input_with_pullup();
 351               		.loc 1 271 0
 352 0008 6093 0000 		sts Transaction_table_size,r22
 353               	.LBB152:
 354               	.LBB153:
 251:drivers/avr/serial.c **** 
 355               		.loc 1 251 0
 356 000c 5298      		cbi 0xa,2
 357 000e 5A9A      		sbi 0xb,2
 358               	.LBE153:
 359               	.LBE152:
 275:drivers/avr/serial.c ****     EICRx &= EICRx_BIT;
 360               		.loc 1 275 0
 361 0010 EA9A      		sbi 0x1d,2
 276:drivers/avr/serial.c **** }
 362               		.loc 1 276 0
 363 0012 E9E6      		ldi r30,lo8(105)
 364 0014 F0E0      		ldi r31,0
 365 0016 8081      		ld r24,Z
 366               	.LVL34:
 367 0018 8F7C      		andi r24,lo8(-49)
 368 001a 8083      		st Z,r24
 369               	.LVL35:
 370 001c 0895      		ret
 371               		.cfi_endproc
 372               	.LFE15:
 374               		.section	.text.serial_write_chunk,"ax",@progbits
 375               	.global	serial_write_chunk
 377               	serial_write_chunk:
 378               	.LFB19:
 329:drivers/avr/serial.c ****     uint8_t b, p;
 379               		.loc 1 329 0
 380               		.cfi_startproc
 381               	.LVL36:
 382               	/* prologue: function */
 383               	/* frame size = 0 */
 384               	/* stack size = 0 */
 385               	.L__stack_usage = 0
 331:drivers/avr/serial.c ****         if (data & b) {
 386               		.loc 1 331 0
 387 0000 6150      		subi r22,lo8(-(-1))
 388               	.LVL37:
 389 0002 91E0      		ldi r25,lo8(1)
 390 0004 00C0      		rjmp 2f
 391               		1:
 392 0006 990F      		lsl r25
 393               		2:
 394 0008 6A95      		dec r22
 395 000a 02F4      		brpl 1b
 396               	.LVL38:
 397 000c 20E0      		ldi r18,0
 334:drivers/avr/serial.c ****         } else {
 398               		.loc 1 334 0
 399 000e 31E0      		ldi r19,lo8(1)
 400               	.LVL39:
 401               	.L29:
 331:drivers/avr/serial.c ****         if (data & b) {
 402               		.loc 1 331 0 discriminator 1
 403 0010 9923      		tst r25
 404 0012 01F0      		breq .L35
 332:drivers/avr/serial.c ****             serial_high();
 405               		.loc 1 332 0
 406 0014 492F      		mov r20,r25
 407 0016 4823      		and r20,r24
 408 0018 01F0      		breq .L30
 409               	.LBB154:
 410               	.LBB155:
 260:drivers/avr/serial.c **** 
 411               		.loc 1 260 0
 412 001a 5A9A      		sbi 0xb,2
 413               	.LBE155:
 414               	.LBE154:
 334:drivers/avr/serial.c ****         } else {
 415               		.loc 1 334 0
 416 001c 2327      		eor r18,r19
 417               	.LVL40:
 418 001e 00C0      		rjmp .L31
 419               	.L30:
 420               	.LBB156:
 421               	.LBB157:
 257:drivers/avr/serial.c **** 
 422               		.loc 1 257 0
 423 0020 5A98      		cbi 0xb,2
 424               	.L31:
 425               	.LVL41:
 426               	.LBE157:
 427               	.LBE156:
 428               	.LBB158:
 429               	.LBB159:
 430               	.LBB160:
 431               		.loc 2 276 0 discriminator 2
 432 0022 40E2      		ldi r20,lo8(32)
 433 0024 4A95      	1:	dec r20
 434 0026 01F4      		brne 1b
 435               	.LVL42:
 436               	.LBE160:
 437               	.LBE159:
 438               	.LBE158:
 331:drivers/avr/serial.c ****         if (data & b) {
 439               		.loc 1 331 0 discriminator 2
 440 0028 9695      		lsr r25
 441               	.LVL43:
 442 002a 00C0      		rjmp .L29
 443               	.L35:
 342:drivers/avr/serial.c ****         serial_high();
 444               		.loc 1 342 0
 445 002c 2223      		tst r18
 446 002e 01F0      		breq .L33
 447               	.LBB161:
 448               	.LBB162:
 260:drivers/avr/serial.c **** 
 449               		.loc 1 260 0
 450 0030 5A9A      		sbi 0xb,2
 451 0032 00C0      		rjmp .L34
 452               	.L33:
 453               	.LBE162:
 454               	.LBE161:
 455               	.LBB163:
 456               	.LBB164:
 257:drivers/avr/serial.c **** 
 457               		.loc 1 257 0
 458 0034 5A98      		cbi 0xb,2
 459               	.L34:
 460               	.LVL44:
 461               	.LBE164:
 462               	.LBE163:
 463               	.LBB165:
 464               	.LBB166:
 465               	.LBB167:
 466               		.loc 2 276 0
 467 0036 80E2      		ldi r24,lo8(32)
 468 0038 8A95      	1:	dec r24
 469 003a 01F4      		brne 1b
 470               	.LVL45:
 471               	.LBE167:
 472               	.LBE166:
 473               	.LBE165:
 474               	.LBB168:
 475               	.LBB169:
 257:drivers/avr/serial.c **** 
 476               		.loc 1 257 0
 477 003c 5A98      		cbi 0xb,2
 478 003e 0895      		ret
 479               	.LBE169:
 480               	.LBE168:
 481               		.cfi_endproc
 482               	.LFE19:
 484               		.section	.text.serial_send_packet,"ax",@progbits
 486               	serial_send_packet:
 487               	.LFB20:
 353:drivers/avr/serial.c ****     for (uint8_t i = 0; i < size; ++i) {
 488               		.loc 1 353 0
 489               		.cfi_startproc
 490               	.LVL46:
 491 0000 FF92      		push r15
 492               	.LCFI8:
 493               		.cfi_def_cfa_offset 3
 494               		.cfi_offset 15, -2
 495 0002 0F93      		push r16
 496               	.LCFI9:
 497               		.cfi_def_cfa_offset 4
 498               		.cfi_offset 16, -3
 499 0004 1F93      		push r17
 500               	.LCFI10:
 501               		.cfi_def_cfa_offset 5
 502               		.cfi_offset 17, -4
 503 0006 CF93      		push r28
 504               	.LCFI11:
 505               		.cfi_def_cfa_offset 6
 506               		.cfi_offset 28, -5
 507 0008 DF93      		push r29
 508               	.LCFI12:
 509               		.cfi_def_cfa_offset 7
 510               		.cfi_offset 29, -6
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 5 */
 514               	.L__stack_usage = 5
 515               	.LVL47:
 516 000a EC01      		movw r28,r24
 517 000c 8C01      		movw r16,r24
 518 000e 060F      		add r16,r22
 519 0010 111D      		adc r17,__zero_reg__
 520               	.LVL48:
 521               	.L37:
 522               	.LBB170:
 354:drivers/avr/serial.c ****         uint8_t data;
 523               		.loc 1 354 0 discriminator 1
 524 0012 C017      		cp r28,r16
 525 0014 D107      		cpc r29,r17
 526 0016 01F0      		breq .L39
 527               	.LBB171:
 356:drivers/avr/serial.c ****         sync_send();
 528               		.loc 1 356 0 discriminator 3
 529 0018 F990      		ld r15,Y+
 530               	.LVL49:
 357:drivers/avr/serial.c ****         serial_write_chunk(data, 8);
 531               		.loc 1 357 0 discriminator 3
 532 001a 0E94 0000 		call sync_send
 533               	.LVL50:
 358:drivers/avr/serial.c ****     }
 534               		.loc 1 358 0 discriminator 3
 535 001e 68E0      		ldi r22,lo8(8)
 536 0020 8F2D      		mov r24,r15
 537 0022 0E94 0000 		call serial_write_chunk
 538               	.LVL51:
 539 0026 00C0      		rjmp .L37
 540               	.LVL52:
 541               	.L39:
 542               	/* epilogue start */
 543               	.LBE171:
 544               	.LBE170:
 360:drivers/avr/serial.c **** 
 545               		.loc 1 360 0
 546 0028 DF91      		pop r29
 547 002a CF91      		pop r28
 548               	.LVL53:
 549 002c 1F91      		pop r17
 550 002e 0F91      		pop r16
 551 0030 FF90      		pop r15
 552 0032 0895      		ret
 553               		.cfi_endproc
 554               	.LFE20:
 556               		.section	.text.__vector_3,"ax",@progbits
 557               	.global	__vector_3
 559               	__vector_3:
 560               	.LFB25:
 373:drivers/avr/serial.c **** 
 374:drivers/avr/serial.c **** inline static void change_sender2reciver(void) {
 375:drivers/avr/serial.c ****     sync_send();                 // 0
 376:drivers/avr/serial.c ****     serial_delay_half1();        // 1
 377:drivers/avr/serial.c ****     serial_low();                // 2
 378:drivers/avr/serial.c ****     serial_input_with_pullup();  // 2
 379:drivers/avr/serial.c ****     serial_delay_half1();        // 3
 380:drivers/avr/serial.c **** }
 381:drivers/avr/serial.c **** 
 382:drivers/avr/serial.c **** inline static void change_reciver2sender(void) {
 383:drivers/avr/serial.c ****     sync_recv();           // 0
 384:drivers/avr/serial.c ****     serial_delay();        // 1
 385:drivers/avr/serial.c ****     serial_low();          // 3
 386:drivers/avr/serial.c ****     serial_output();       // 3
 387:drivers/avr/serial.c ****     serial_delay_half1();  // 4
 388:drivers/avr/serial.c **** }
 389:drivers/avr/serial.c **** 
 390:drivers/avr/serial.c **** static inline uint8_t nibble_bits_count(uint8_t bits) {
 391:drivers/avr/serial.c ****     bits = (bits & 0x5) + (bits >> 1 & 0x5);
 392:drivers/avr/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 393:drivers/avr/serial.c ****     return bits;
 394:drivers/avr/serial.c **** }
 395:drivers/avr/serial.c **** 
 396:drivers/avr/serial.c **** // interrupt handle to be used by the target device
 397:drivers/avr/serial.c **** ISR(SERIAL_PIN_INTERRUPT) {
 561               		.loc 1 397 0
 562               		.cfi_startproc
 563 0000 1F92      		push r1
 564               	.LCFI13:
 565               		.cfi_def_cfa_offset 3
 566               		.cfi_offset 1, -2
 567 0002 0F92      		push r0
 568               	.LCFI14:
 569               		.cfi_def_cfa_offset 4
 570               		.cfi_offset 0, -3
 571 0004 0FB6      		in r0,__SREG__
 572 0006 0F92      		push r0
 573 0008 1124      		clr __zero_reg__
 574 000a 0F93      		push r16
 575               	.LCFI15:
 576               		.cfi_def_cfa_offset 5
 577               		.cfi_offset 16, -4
 578 000c 1F93      		push r17
 579               	.LCFI16:
 580               		.cfi_def_cfa_offset 6
 581               		.cfi_offset 17, -5
 582 000e 2F93      		push r18
 583               	.LCFI17:
 584               		.cfi_def_cfa_offset 7
 585               		.cfi_offset 18, -6
 586 0010 3F93      		push r19
 587               	.LCFI18:
 588               		.cfi_def_cfa_offset 8
 589               		.cfi_offset 19, -7
 590 0012 4F93      		push r20
 591               	.LCFI19:
 592               		.cfi_def_cfa_offset 9
 593               		.cfi_offset 20, -8
 594 0014 5F93      		push r21
 595               	.LCFI20:
 596               		.cfi_def_cfa_offset 10
 597               		.cfi_offset 21, -9
 598 0016 6F93      		push r22
 599               	.LCFI21:
 600               		.cfi_def_cfa_offset 11
 601               		.cfi_offset 22, -10
 602 0018 7F93      		push r23
 603               	.LCFI22:
 604               		.cfi_def_cfa_offset 12
 605               		.cfi_offset 23, -11
 606 001a 8F93      		push r24
 607               	.LCFI23:
 608               		.cfi_def_cfa_offset 13
 609               		.cfi_offset 24, -12
 610 001c 9F93      		push r25
 611               	.LCFI24:
 612               		.cfi_def_cfa_offset 14
 613               		.cfi_offset 25, -13
 614 001e AF93      		push r26
 615               	.LCFI25:
 616               		.cfi_def_cfa_offset 15
 617               		.cfi_offset 26, -14
 618 0020 BF93      		push r27
 619               	.LCFI26:
 620               		.cfi_def_cfa_offset 16
 621               		.cfi_offset 27, -15
 622 0022 EF93      		push r30
 623               	.LCFI27:
 624               		.cfi_def_cfa_offset 17
 625               		.cfi_offset 30, -16
 626 0024 FF93      		push r31
 627               	.LCFI28:
 628               		.cfi_def_cfa_offset 18
 629               		.cfi_offset 31, -17
 630 0026 CF93      		push r28
 631               	.LCFI29:
 632               		.cfi_def_cfa_offset 19
 633               		.cfi_offset 28, -18
 634 0028 DF93      		push r29
 635               	.LCFI30:
 636               		.cfi_def_cfa_offset 20
 637               		.cfi_offset 29, -19
 638 002a 1F92      		push __zero_reg__
 639               	.LCFI31:
 640               		.cfi_def_cfa_offset 21
 641 002c CDB7      		in r28,__SP_L__
 642 002e DEB7      		in r29,__SP_H__
 643               	.LCFI32:
 644               		.cfi_def_cfa_register 28
 645               	/* prologue: Signal */
 646               	/* frame size = 1 */
 647               	/* stack size = 20 */
 648               	.L__stack_usage = 20
 398:drivers/avr/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 399:drivers/avr/serial.c ****     serial_low();
 400:drivers/avr/serial.c ****     serial_output();
 401:drivers/avr/serial.c ****     SSTD_t *trans = Transaction_table;
 402:drivers/avr/serial.c **** #    else
 403:drivers/avr/serial.c ****     // recive transaction table index
 404:drivers/avr/serial.c ****     uint8_t tid, bits;
 405:drivers/avr/serial.c ****     uint8_t pecount = 0;
 649               		.loc 1 405 0
 650 0030 1982      		std Y+1,__zero_reg__
 406:drivers/avr/serial.c ****     sync_recv();
 651               		.loc 1 406 0
 652 0032 0E94 0000 		call sync_recv
 653               	.LVL54:
 407:drivers/avr/serial.c ****     bits = serial_read_chunk(&pecount, 7);
 654               		.loc 1 407 0
 655 0036 67E0      		ldi r22,lo8(7)
 656 0038 CE01      		movw r24,r28
 657 003a 0196      		adiw r24,1
 658 003c 0E94 0000 		call serial_read_chunk
 659               	.LVL55:
 408:drivers/avr/serial.c ****     tid  = bits >> 3;
 660               		.loc 1 408 0
 661 0040 382F      		mov r19,r24
 662 0042 3695      		lsr r19
 663 0044 3695      		lsr r19
 664 0046 3695      		lsr r19
 665               	.LVL56:
 666               	.LBB195:
 667               	.LBB196:
 391:drivers/avr/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 668               		.loc 1 391 0
 669 0048 932F      		mov r25,r19
 670 004a 9695      		lsr r25
 671 004c 9570      		andi r25,lo8(5)
 672 004e 232F      		mov r18,r19
 673 0050 2570      		andi r18,lo8(5)
 674 0052 920F      		add r25,r18
 675               	.LVL57:
 392:drivers/avr/serial.c ****     return bits;
 676               		.loc 1 392 0
 677 0054 292F      		mov r18,r25
 678 0056 2370      		andi r18,lo8(3)
 679 0058 9695      		lsr r25
 680 005a 9695      		lsr r25
 681               	.LVL58:
 682               	.LBE196:
 683               	.LBE195:
 409:drivers/avr/serial.c ****     bits = (bits & 7) != nibble_bits_count(tid);
 410:drivers/avr/serial.c ****     if (bits || pecount > 0 || tid > Transaction_table_size) {
 684               		.loc 1 410 0
 685 005c 8770      		andi r24,lo8(7)
 686               	.LVL59:
 687 005e 920F      		add r25,r18
 688 0060 8913      		cpse r24,r25
 689 0062 00C0      		rjmp .L40
 690               		.loc 1 410 0 is_stmt 0 discriminator 1
 691 0064 8981      		ldd r24,Y+1
 692 0066 8111      		cpse r24,__zero_reg__
 693 0068 00C0      		rjmp .L40
 694               		.loc 1 410 0 discriminator 2
 695 006a 8091 0000 		lds r24,Transaction_table_size
 696 006e 8317      		cp r24,r19
 697 0070 00F4      		brsh .+2
 698 0072 00C0      		rjmp .L40
 699               	.LVL60:
 700               	.LBB197:
 701               	.LBB198:
 702               	.LBB199:
 703               		.loc 2 276 0 is_stmt 1
 704 0074 80E1      		ldi r24,lo8(16)
 705 0076 8A95      	1:	dec r24
 706 0078 01F4      		brne 1b
 707               	.LVL61:
 708               	.LBE199:
 709               	.LBE198:
 710               	.LBE197:
 711               	.LBB200:
 712               	.LBB201:
 260:drivers/avr/serial.c **** 
 713               		.loc 1 260 0
 714 007a 5A9A      		sbi 0xb,2
 715               	.LBE201:
 716               	.LBE200:
 717               	.LBB202:
 718               	.LBB203:
 247:drivers/avr/serial.c **** 
 719               		.loc 1 247 0
 720 007c 529A      		sbi 0xa,2
 721               	.LBE203:
 722               	.LBE202:
 411:drivers/avr/serial.c ****         return;
 412:drivers/avr/serial.c ****     }
 413:drivers/avr/serial.c ****     serial_delay_half1();
 414:drivers/avr/serial.c **** 
 415:drivers/avr/serial.c ****     serial_high();  // response step1 low->high
 416:drivers/avr/serial.c ****     serial_output();
 417:drivers/avr/serial.c ****     _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT * SLAVE_INT_ACK_WIDTH);
 723               		.loc 1 417 0
 724 007e A2E0      		ldi r26,lo8(2)
 725 0080 AA95      	1:	dec r26
 726 0082 01F4      		brne 1b
 727 0084 00C0      		rjmp .
 418:drivers/avr/serial.c ****     SSTD_t *trans = &Transaction_table[tid];
 728               		.loc 1 418 0
 729 0086 0091 0000 		lds r16,Transaction_table
 730 008a 1091 0000 		lds r17,Transaction_table+1
 731 008e B8E0      		ldi r27,lo8(8)
 732 0090 3B9F      		mul r19,r27
 733 0092 000D      		add r16,r0
 734 0094 111D      		adc r17,r1
 735 0096 1124      		clr __zero_reg__
 736               	.LVL62:
 737               	.LBB204:
 738               	.LBB205:
 257:drivers/avr/serial.c **** 
 739               		.loc 1 257 0
 740 0098 5A98      		cbi 0xb,2
 741               	.LBE205:
 742               	.LBE204:
 419:drivers/avr/serial.c ****     serial_low();  // response step2 ack high->low
 420:drivers/avr/serial.c **** #    endif
 421:drivers/avr/serial.c **** 
 422:drivers/avr/serial.c ****     // target send phase
 423:drivers/avr/serial.c ****     if (trans->target2initiator_buffer_size > 0) serial_send_packet((uint8_t *)trans->target2initia
 743               		.loc 1 423 0
 744 009a F801      		movw r30,r16
 745 009c 6581      		ldd r22,Z+5
 746 009e 6623      		tst r22
 747 00a0 01F0      		breq .L42
 748               		.loc 1 423 0 is_stmt 0 discriminator 1
 749 00a2 8681      		ldd r24,Z+6
 750 00a4 9781      		ldd r25,Z+7
 751 00a6 0E94 0000 		call serial_send_packet
 752               	.LVL63:
 753               	.L42:
 754               	.LBB206:
 755               	.LBB207:
 375:drivers/avr/serial.c ****     serial_delay_half1();        // 1
 756               		.loc 1 375 0 is_stmt 1
 757 00aa 0E94 0000 		call sync_send
 758               	.LVL64:
 759               	.LBB208:
 760               	.LBB209:
 761               	.LBB210:
 762               		.loc 2 276 0
 763 00ae F0E1      		ldi r31,lo8(16)
 764 00b0 FA95      	1:	dec r31
 765 00b2 01F4      		brne 1b
 766               	.LVL65:
 767               	.LBE210:
 768               	.LBE209:
 769               	.LBE208:
 770               	.LBB211:
 771               	.LBB212:
 257:drivers/avr/serial.c **** 
 772               		.loc 1 257 0
 773 00b4 5A98      		cbi 0xb,2
 774               	.LBE212:
 775               	.LBE211:
 776               	.LBB213:
 777               	.LBB214:
 251:drivers/avr/serial.c **** 
 778               		.loc 1 251 0
 779 00b6 5298      		cbi 0xa,2
 780 00b8 5A9A      		sbi 0xb,2
 781               	.LVL66:
 782               	.LBE214:
 783               	.LBE213:
 784               	.LBB215:
 785               	.LBB216:
 786               	.LBB217:
 787               		.loc 2 276 0
 788 00ba 80E1      		ldi r24,lo8(16)
 789 00bc 8A95      	1:	dec r24
 790 00be 01F4      		brne 1b
 791               	.LVL67:
 792               	.LBE217:
 793               	.LBE216:
 794               	.LBE215:
 795               	.LBE207:
 796               	.LBE206:
 424:drivers/avr/serial.c ****     // target switch to input
 425:drivers/avr/serial.c ****     change_sender2reciver();
 426:drivers/avr/serial.c **** 
 427:drivers/avr/serial.c ****     // target recive phase
 428:drivers/avr/serial.c ****     if (trans->initiator2target_buffer_size > 0) {
 797               		.loc 1 428 0
 798 00c0 D801      		movw r26,r16
 799 00c2 1296      		adiw r26,2
 800 00c4 6C91      		ld r22,X
 801 00c6 1297      		sbiw r26,2
 802 00c8 6623      		tst r22
 803 00ca 01F0      		breq .L43
 429:drivers/avr/serial.c ****         if (serial_recive_packet((uint8_t *)trans->initiator2target_buffer, trans->initiator2target
 804               		.loc 1 429 0
 805 00cc 1396      		adiw r26,3
 806 00ce 8D91      		ld r24,X+
 807 00d0 9C91      		ld r25,X
 808 00d2 1497      		sbiw r26,3+1
 809 00d4 0E94 0000 		call serial_recive_packet
 810               	.LVL68:
 811 00d8 D801      		movw r26,r16
 812 00da ED91      		ld r30,X+
 813 00dc FC91      		ld r31,X
 814 00de 8111      		cpse r24,__zero_reg__
 815 00e0 00C0      		rjmp .L50
 430:drivers/avr/serial.c ****             *trans->status = TRANSACTION_ACCEPTED;
 431:drivers/avr/serial.c ****         } else {
 432:drivers/avr/serial.c ****             *trans->status = TRANSACTION_DATA_ERROR;
 816               		.loc 1 432 0
 817 00e2 82E0      		ldi r24,lo8(2)
 818 00e4 00C0      		rjmp .L51
 819               	.L43:
 433:drivers/avr/serial.c ****         }
 434:drivers/avr/serial.c ****     } else {
 435:drivers/avr/serial.c ****         *trans->status = TRANSACTION_ACCEPTED;
 820               		.loc 1 435 0
 821 00e6 D801      		movw r26,r16
 822 00e8 ED91      		ld r30,X+
 823 00ea FC91      		ld r31,X
 824               	.L50:
 825 00ec 88E0      		ldi r24,lo8(8)
 826               	.L51:
 827 00ee 8083      		st Z,r24
 436:drivers/avr/serial.c ****     }
 437:drivers/avr/serial.c **** 
 438:drivers/avr/serial.c ****     sync_recv();  // weit initiator output to high
 828               		.loc 1 438 0
 829 00f0 0E94 0000 		call sync_recv
 830               	.LVL69:
 831               	.L40:
 832               	/* epilogue start */
 439:drivers/avr/serial.c **** }
 833               		.loc 1 439 0
 834 00f4 0F90      		pop __tmp_reg__
 835 00f6 DF91      		pop r29
 836 00f8 CF91      		pop r28
 837 00fa FF91      		pop r31
 838 00fc EF91      		pop r30
 839 00fe BF91      		pop r27
 840 0100 AF91      		pop r26
 841 0102 9F91      		pop r25
 842 0104 8F91      		pop r24
 843 0106 7F91      		pop r23
 844 0108 6F91      		pop r22
 845 010a 5F91      		pop r21
 846 010c 4F91      		pop r20
 847 010e 3F91      		pop r19
 848 0110 2F91      		pop r18
 849 0112 1F91      		pop r17
 850 0114 0F91      		pop r16
 851 0116 0F90      		pop r0
 852 0118 0FBE      		out __SREG__,r0
 853 011a 0F90      		pop r0
 854 011c 1F90      		pop r1
 855 011e 1895      		reti
 856               		.cfi_endproc
 857               	.LFE25:
 859               		.section	.text.soft_serial_transaction,"ax",@progbits
 860               	.global	soft_serial_transaction
 862               	soft_serial_transaction:
 863               	.LFB26:
 440:drivers/avr/serial.c **** 
 441:drivers/avr/serial.c **** /////////
 442:drivers/avr/serial.c **** //  start transaction by initiator
 443:drivers/avr/serial.c **** //
 444:drivers/avr/serial.c **** // int  soft_serial_transaction(int sstd_index)
 445:drivers/avr/serial.c **** //
 446:drivers/avr/serial.c **** // Returns:
 447:drivers/avr/serial.c **** //    TRANSACTION_END
 448:drivers/avr/serial.c **** //    TRANSACTION_NO_RESPONSE
 449:drivers/avr/serial.c **** //    TRANSACTION_DATA_ERROR
 450:drivers/avr/serial.c **** // this code is very time dependent, so we need to disable interrupts
 451:drivers/avr/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 452:drivers/avr/serial.c **** int soft_serial_transaction(void) {
 453:drivers/avr/serial.c ****     SSTD_t *trans = Transaction_table;
 454:drivers/avr/serial.c **** #    else
 455:drivers/avr/serial.c **** int soft_serial_transaction(int sstd_index) {
 864               		.loc 1 455 0
 865               		.cfi_startproc
 866               	.LVL70:
 867 0000 0F93      		push r16
 868               	.LCFI33:
 869               		.cfi_def_cfa_offset 3
 870               		.cfi_offset 16, -2
 871 0002 1F93      		push r17
 872               	.LCFI34:
 873               		.cfi_def_cfa_offset 4
 874               		.cfi_offset 17, -3
 875 0004 CF93      		push r28
 876               	.LCFI35:
 877               		.cfi_def_cfa_offset 5
 878               		.cfi_offset 28, -4
 879 0006 DF93      		push r29
 880               	.LCFI36:
 881               		.cfi_def_cfa_offset 6
 882               		.cfi_offset 29, -5
 883               	/* prologue: function */
 884               	/* frame size = 0 */
 885               	/* stack size = 4 */
 886               	.L__stack_usage = 4
 456:drivers/avr/serial.c ****     if (sstd_index > Transaction_table_size) return TRANSACTION_TYPE_ERROR;
 887               		.loc 1 456 0
 888 0008 2091 0000 		lds r18,Transaction_table_size
 889 000c 30E0      		ldi r19,0
 890 000e 2817      		cp r18,r24
 891 0010 3907      		cpc r19,r25
 892 0012 04F4      		brge .+2
 893 0014 00C0      		rjmp .L61
 457:drivers/avr/serial.c ****     SSTD_t *trans = &Transaction_table[sstd_index];
 894               		.loc 1 457 0
 895 0016 9C01      		movw r18,r24
 896 0018 93E0      		ldi r25,3
 897               		1:
 898 001a 220F      		lsl r18
 899 001c 331F      		rol r19
 900 001e 9A95      		dec r25
 901 0020 01F4      		brne 1b
 902 0022 C091 0000 		lds r28,Transaction_table
 903 0026 D091 0000 		lds r29,Transaction_table+1
 904 002a C20F      		add r28,r18
 905 002c D31F      		adc r29,r19
 906               	.LVL71:
 458:drivers/avr/serial.c **** #    endif
 459:drivers/avr/serial.c ****     cli();
 907               		.loc 1 459 0
 908               	/* #APP */
 909               	 ;  459 "drivers/avr/serial.c" 1
 910 002e F894      		cli
 911               	 ;  0 "" 2
 912               	/* #NOAPP */
 913               	.LBB256:
 914               	.LBB257:
 247:drivers/avr/serial.c **** 
 915               		.loc 1 247 0
 916 0030 529A      		sbi 0xa,2
 917               	.LBE257:
 918               	.LBE256:
 919               	.LBB258:
 920               	.LBB259:
 257:drivers/avr/serial.c **** 
 921               		.loc 1 257 0
 922 0032 5A98      		cbi 0xb,2
 923               	.LVL72:
 924               	.LBE259:
 925               	.LBE258:
 926               	.LBB260:
 927               	.LBB261:
 928               		.loc 2 276 0
 929 0034 45E0      		ldi r20,lo8(5)
 930 0036 4A95      	1:	dec r20
 931 0038 01F4      		brne 1b
 932 003a 0000      		nop
 933               	.LVL73:
 934               	.LBE261:
 935               	.LBE260:
 936               	.LBB262:
 937               	.LBB263:
 391:drivers/avr/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 938               		.loc 1 391 0
 939 003c 982F      		mov r25,r24
 940 003e 9695      		lsr r25
 941 0040 9570      		andi r25,lo8(5)
 942 0042 8570      		andi r24,lo8(5)
 943               	.LVL74:
 944 0044 890F      		add r24,r25
 945               	.LVL75:
 392:drivers/avr/serial.c ****     return bits;
 946               		.loc 1 392 0
 947 0046 982F      		mov r25,r24
 948 0048 9370      		andi r25,lo8(3)
 949 004a 8695      		lsr r24
 950 004c 8695      		lsr r24
 951               	.LVL76:
 952               	.LBE263:
 953               	.LBE262:
 460:drivers/avr/serial.c **** 
 461:drivers/avr/serial.c ****     // signal to the target that we want to start a transaction
 462:drivers/avr/serial.c ****     serial_output();
 463:drivers/avr/serial.c ****     serial_low();
 464:drivers/avr/serial.c ****     _delay_us(SLAVE_INT_WIDTH_US);
 465:drivers/avr/serial.c **** 
 466:drivers/avr/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 467:drivers/avr/serial.c ****     // wait for the target response
 468:drivers/avr/serial.c ****     serial_input_with_pullup();
 469:drivers/avr/serial.c ****     _delay_us(SLAVE_INT_RESPONSE_TIME);
 470:drivers/avr/serial.c **** 
 471:drivers/avr/serial.c ****     // check if the target is present
 472:drivers/avr/serial.c ****     if (serial_read_pin()) {
 473:drivers/avr/serial.c ****         // target failed to pull the line low, assume not present
 474:drivers/avr/serial.c ****         serial_output();
 475:drivers/avr/serial.c ****         serial_high();
 476:drivers/avr/serial.c ****         *trans->status = TRANSACTION_NO_RESPONSE;
 477:drivers/avr/serial.c ****         sei();
 478:drivers/avr/serial.c ****         return TRANSACTION_NO_RESPONSE;
 479:drivers/avr/serial.c ****     }
 480:drivers/avr/serial.c **** 
 481:drivers/avr/serial.c **** #    else
 482:drivers/avr/serial.c ****     // send transaction table index
 483:drivers/avr/serial.c ****     int tid = (sstd_index << 3) | (7 & nibble_bits_count(sstd_index));
 954               		.loc 1 483 0
 955 004e 890F      		add r24,r25
 956 0050 8901      		movw r16,r18
 957 0052 082B      		or r16,r24
 484:drivers/avr/serial.c ****     sync_send();
 958               		.loc 1 484 0
 959 0054 0E94 0000 		call sync_send
 960               	.LVL77:
 485:drivers/avr/serial.c ****     _delay_sub_us(TID_SEND_ADJUST);
 961               		.loc 1 485 0
 962 0058 84E0      		ldi r24,lo8(4)
 963 005a 8A95      	1:	dec r24
 964 005c 01F4      		brne 1b
 965 005e 00C0      		rjmp .
 486:drivers/avr/serial.c ****     serial_write_chunk(tid, 7);
 966               		.loc 1 486 0
 967 0060 67E0      		ldi r22,lo8(7)
 968 0062 802F      		mov r24,r16
 969 0064 0E94 0000 		call serial_write_chunk
 970               	.LVL78:
 971               	.LBB264:
 972               	.LBB265:
 973               	.LBB266:
 974               		.loc 2 276 0
 975 0068 40E1      		ldi r20,lo8(16)
 976 006a 4A95      	1:	dec r20
 977 006c 01F4      		brne 1b
 978               	.LVL79:
 979               	.LBE266:
 980               	.LBE265:
 981               	.LBE264:
 982               	.LBB267:
 983               	.LBB268:
 251:drivers/avr/serial.c **** 
 984               		.loc 1 251 0
 985 006e 5298      		cbi 0xa,2
 986 0070 5A9A      		sbi 0xb,2
 987               	.L54:
 988               	.LBE268:
 989               	.LBE267:
 487:drivers/avr/serial.c ****     serial_delay_half1();
 488:drivers/avr/serial.c **** 
 489:drivers/avr/serial.c ****     // wait for the target response (step1 low->high)
 490:drivers/avr/serial.c ****     serial_input_with_pullup();
 491:drivers/avr/serial.c ****     while (!serial_read_pin()) {
 990               		.loc 1 491 0
 991 0072 4A99      		sbic 0x9,2
 992 0074 00C0      		rjmp .L68
 492:drivers/avr/serial.c ****         _delay_sub_us(2);
 993               		.loc 1 492 0
 994 0076 00C0      		rjmp .
 995 0078 00C0      		rjmp .L54
 996               	.L68:
 997 007a 87E0      		ldi r24,lo8(7)
 998 007c 90E0      		ldi r25,0
 999               	.L56:
 1000               	.LVL80:
 1001               	.LBB269:
 493:drivers/avr/serial.c ****     }
 494:drivers/avr/serial.c **** 
 495:drivers/avr/serial.c ****     // check if the target is present (step2 high->low)
 496:drivers/avr/serial.c ****     for (int i = 0; serial_read_pin(); i++) {
 1002               		.loc 1 496 0 discriminator 1
 1003 007e 4A9B      		sbis 0x9,2
 1004 0080 00C0      		rjmp .L69
 1005 0082 0197      		sbiw r24,1
 1006               	.LVL81:
 497:drivers/avr/serial.c ****         if (i > SLAVE_INT_ACK_WIDTH + 1) {
 1007               		.loc 1 497 0
 1008 0084 01F4      		brne .L57
 1009               	.LBB270:
 1010               	.LBB271:
 247:drivers/avr/serial.c **** 
 1011               		.loc 1 247 0
 1012 0086 529A      		sbi 0xa,2
 1013               	.LBE271:
 1014               	.LBE270:
 1015               	.LBB272:
 1016               	.LBB273:
 260:drivers/avr/serial.c **** 
 1017               		.loc 1 260 0
 1018 0088 5A9A      		sbi 0xb,2
 1019               	.LBE273:
 1020               	.LBE272:
 498:drivers/avr/serial.c ****             // slave failed to pull the line low, assume not present
 499:drivers/avr/serial.c ****             serial_output();
 500:drivers/avr/serial.c ****             serial_high();
 501:drivers/avr/serial.c ****             *trans->status = TRANSACTION_NO_RESPONSE;
 1021               		.loc 1 501 0
 1022 008a E881      		ld r30,Y
 1023 008c F981      		ldd r31,Y+1
 1024 008e 81E0      		ldi r24,lo8(1)
 1025               	.LVL82:
 1026 0090 8083      		st Z,r24
 502:drivers/avr/serial.c ****             sei();
 1027               		.loc 1 502 0
 1028               	/* #APP */
 1029               	 ;  502 "drivers/avr/serial.c" 1
 1030 0092 7894      		sei
 1031               	 ;  0 "" 2
 503:drivers/avr/serial.c ****             return TRANSACTION_NO_RESPONSE;
 1032               		.loc 1 503 0
 1033               	/* #NOAPP */
 1034 0094 81E0      		ldi r24,lo8(1)
 1035 0096 90E0      		ldi r25,0
 1036 0098 00C0      		rjmp .L53
 1037               	.LVL83:
 1038               	.L57:
 504:drivers/avr/serial.c ****         }
 505:drivers/avr/serial.c ****         _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT);
 1039               		.loc 1 505 0 discriminator 2
 1040 009a 00C0      		rjmp .
 1041               	.LVL84:
 1042 009c 00C0      		rjmp .L56
 1043               	.L69:
 1044               	.LBE269:
 506:drivers/avr/serial.c ****     }
 507:drivers/avr/serial.c **** #    endif
 508:drivers/avr/serial.c **** 
 509:drivers/avr/serial.c ****     // initiator recive phase
 510:drivers/avr/serial.c ****     // if the target is present syncronize with it
 511:drivers/avr/serial.c ****     if (trans->target2initiator_buffer_size > 0) {
 1045               		.loc 1 511 0
 1046 009e 6D81      		ldd r22,Y+5
 1047 00a0 6623      		tst r22
 1048 00a2 01F0      		breq .L59
 512:drivers/avr/serial.c ****         if (!serial_recive_packet((uint8_t *)trans->target2initiator_buffer, trans->target2initiato
 1049               		.loc 1 512 0
 1050 00a4 8E81      		ldd r24,Y+6
 1051 00a6 9F81      		ldd r25,Y+7
 1052               	.LVL85:
 1053 00a8 0E94 0000 		call serial_recive_packet
 1054               	.LVL86:
 1055 00ac 8111      		cpse r24,__zero_reg__
 1056 00ae 00C0      		rjmp .L59
 1057               	.LBB274:
 1058               	.LBB275:
 247:drivers/avr/serial.c **** 
 1059               		.loc 1 247 0
 1060 00b0 529A      		sbi 0xa,2
 1061               	.LBE275:
 1062               	.LBE274:
 1063               	.LBB276:
 1064               	.LBB277:
 260:drivers/avr/serial.c **** 
 1065               		.loc 1 260 0
 1066 00b2 5A9A      		sbi 0xb,2
 1067               	.LBE277:
 1068               	.LBE276:
 513:drivers/avr/serial.c ****             serial_output();
 514:drivers/avr/serial.c ****             serial_high();
 515:drivers/avr/serial.c ****             *trans->status = TRANSACTION_DATA_ERROR;
 1069               		.loc 1 515 0
 1070 00b4 E881      		ld r30,Y
 1071 00b6 F981      		ldd r31,Y+1
 1072 00b8 82E0      		ldi r24,lo8(2)
 1073 00ba 8083      		st Z,r24
 516:drivers/avr/serial.c ****             sei();
 1074               		.loc 1 516 0
 1075               	/* #APP */
 1076               	 ;  516 "drivers/avr/serial.c" 1
 1077 00bc 7894      		sei
 1078               	 ;  0 "" 2
 517:drivers/avr/serial.c ****             return TRANSACTION_DATA_ERROR;
 1079               		.loc 1 517 0
 1080               	/* #NOAPP */
 1081 00be 82E0      		ldi r24,lo8(2)
 1082 00c0 90E0      		ldi r25,0
 1083 00c2 00C0      		rjmp .L53
 1084               	.L59:
 1085               	.LBB278:
 1086               	.LBB279:
 383:drivers/avr/serial.c ****     serial_delay();        // 1
 1087               		.loc 1 383 0
 1088 00c4 0E94 0000 		call sync_recv
 1089               	.LVL87:
 1090               	.LBB280:
 1091               	.LBB281:
 1092               	.LBB282:
 1093               		.loc 2 276 0
 1094 00c8 80E2      		ldi r24,lo8(32)
 1095 00ca 8A95      	1:	dec r24
 1096 00cc 01F4      		brne 1b
 1097               	.LVL88:
 1098               	.LBE282:
 1099               	.LBE281:
 1100               	.LBE280:
 1101               	.LBB283:
 1102               	.LBB284:
 257:drivers/avr/serial.c **** 
 1103               		.loc 1 257 0
 1104 00ce 5A98      		cbi 0xb,2
 1105               	.LBE284:
 1106               	.LBE283:
 1107               	.LBB285:
 1108               	.LBB286:
 247:drivers/avr/serial.c **** 
 1109               		.loc 1 247 0
 1110 00d0 529A      		sbi 0xa,2
 1111               	.LVL89:
 1112               	.LBE286:
 1113               	.LBE285:
 1114               	.LBB287:
 1115               	.LBB288:
 1116               	.LBB289:
 1117               		.loc 2 276 0
 1118 00d2 40E1      		ldi r20,lo8(16)
 1119 00d4 4A95      	1:	dec r20
 1120 00d6 01F4      		brne 1b
 1121               	.LVL90:
 1122               	.LBE289:
 1123               	.LBE288:
 1124               	.LBE287:
 1125               	.LBE279:
 1126               	.LBE278:
 518:drivers/avr/serial.c ****         }
 519:drivers/avr/serial.c ****     }
 520:drivers/avr/serial.c **** 
 521:drivers/avr/serial.c ****     // initiator switch to output
 522:drivers/avr/serial.c ****     change_reciver2sender();
 523:drivers/avr/serial.c **** 
 524:drivers/avr/serial.c ****     // initiator send phase
 525:drivers/avr/serial.c ****     if (trans->initiator2target_buffer_size > 0) {
 1127               		.loc 1 525 0
 1128 00d8 6A81      		ldd r22,Y+2
 1129 00da 6623      		tst r22
 1130 00dc 01F0      		breq .L60
 526:drivers/avr/serial.c ****         serial_send_packet((uint8_t *)trans->initiator2target_buffer, trans->initiator2target_buffe
 1131               		.loc 1 526 0
 1132 00de 8B81      		ldd r24,Y+3
 1133 00e0 9C81      		ldd r25,Y+4
 1134 00e2 0E94 0000 		call serial_send_packet
 1135               	.LVL91:
 1136               	.L60:
 527:drivers/avr/serial.c ****     }
 528:drivers/avr/serial.c **** 
 529:drivers/avr/serial.c ****     // always, release the line when not in use
 530:drivers/avr/serial.c ****     sync_send();
 1137               		.loc 1 530 0
 1138 00e6 0E94 0000 		call sync_send
 1139               	.LVL92:
 531:drivers/avr/serial.c **** 
 532:drivers/avr/serial.c ****     *trans->status = TRANSACTION_END;
 1140               		.loc 1 532 0
 1141 00ea E881      		ld r30,Y
 1142 00ec F981      		ldd r31,Y+1
 1143 00ee 1082      		st Z,__zero_reg__
 533:drivers/avr/serial.c ****     sei();
 1144               		.loc 1 533 0
 1145               	/* #APP */
 1146               	 ;  533 "drivers/avr/serial.c" 1
 1147 00f0 7894      		sei
 1148               	 ;  0 "" 2
 534:drivers/avr/serial.c ****     return TRANSACTION_END;
 1149               		.loc 1 534 0
 1150               	/* #NOAPP */
 1151 00f2 80E0      		ldi r24,0
 1152 00f4 90E0      		ldi r25,0
 1153 00f6 00C0      		rjmp .L53
 1154               	.LVL93:
 1155               	.L61:
 456:drivers/avr/serial.c ****     SSTD_t *trans = &Transaction_table[sstd_index];
 1156               		.loc 1 456 0
 1157 00f8 84E0      		ldi r24,lo8(4)
 1158 00fa 90E0      		ldi r25,0
 1159               	.LVL94:
 1160               	.L53:
 1161               	/* epilogue start */
 535:drivers/avr/serial.c **** }
 1162               		.loc 1 535 0
 1163 00fc DF91      		pop r29
 1164 00fe CF91      		pop r28
 1165 0100 1F91      		pop r17
 1166 0102 0F91      		pop r16
 1167 0104 0895      		ret
 1168               		.cfi_endproc
 1169               	.LFE26:
 1171               		.section	.text.soft_serial_get_and_clean_status,"ax",@progbits
 1172               	.global	soft_serial_get_and_clean_status
 1174               	soft_serial_get_and_clean_status:
 1175               	.LFB27:
 536:drivers/avr/serial.c **** 
 537:drivers/avr/serial.c **** #    ifdef SERIAL_USE_MULTI_TRANSACTION
 538:drivers/avr/serial.c **** int soft_serial_get_and_clean_status(int sstd_index) {
 1176               		.loc 1 538 0
 1177               		.cfi_startproc
 1178               	.LVL95:
 1179               	/* prologue: function */
 1180               	/* frame size = 0 */
 1181               	/* stack size = 0 */
 1182               	.L__stack_usage = 0
 539:drivers/avr/serial.c ****     SSTD_t *trans = &Transaction_table[sstd_index];
 1183               		.loc 1 539 0
 1184 0000 23E0      		ldi r18,3
 1185               		1:
 1186 0002 880F      		lsl r24
 1187 0004 991F      		rol r25
 1188 0006 2A95      		dec r18
 1189 0008 01F4      		brne 1b
 1190               	.LVL96:
 1191 000a E091 0000 		lds r30,Transaction_table
 1192 000e F091 0000 		lds r31,Transaction_table+1
 1193 0012 E80F      		add r30,r24
 1194 0014 F91F      		adc r31,r25
 1195               	.LVL97:
 540:drivers/avr/serial.c ****     cli();
 1196               		.loc 1 540 0
 1197               	/* #APP */
 1198               	 ;  540 "drivers/avr/serial.c" 1
 1199 0016 F894      		cli
 1200               	 ;  0 "" 2
 541:drivers/avr/serial.c ****     int retval     = *trans->status;
 1201               		.loc 1 541 0
 1202               	/* #NOAPP */
 1203 0018 0190      		ld __tmp_reg__,Z+
 1204 001a F081      		ld r31,Z
 1205 001c E02D      		mov r30,__tmp_reg__
 1206               	.LVL98:
 1207 001e 8081      		ld r24,Z
 1208               	.LVL99:
 1209 0020 90E0      		ldi r25,0
 1210               	.LVL100:
 542:drivers/avr/serial.c ****     *trans->status = 0;
 1211               		.loc 1 542 0
 1212 0022 1082      		st Z,__zero_reg__
 543:drivers/avr/serial.c ****     ;
 544:drivers/avr/serial.c ****     sei();
 1213               		.loc 1 544 0
 1214               	/* #APP */
 1215               	 ;  544 "drivers/avr/serial.c" 1
 1216 0024 7894      		sei
 1217               	 ;  0 "" 2
 545:drivers/avr/serial.c ****     return retval;
 546:drivers/avr/serial.c **** }
 1218               		.loc 1 546 0
 1219               	/* #NOAPP */
 1220 0026 0895      		ret
 1221               		.cfi_endproc
 1222               	.LFE27:
 1224               		.section	.bss.Transaction_table_size,"aw",@nobits
 1227               	Transaction_table_size:
 1228 0000 00        		.zero	1
 1229               		.section	.bss.Transaction_table,"aw",@nobits
 1232               	Transaction_table:
 1233 0000 0000      		.zero	2
 1234               		.text
 1235               	.Letext0:
 1236               		.file 3 "/usr/lib/avr/include/stdint.h"
 1237               		.file 4 "drivers/avr/serial.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial.c
     /tmp/cc58xWKD.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc58xWKD.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc58xWKD.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc58xWKD.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc58xWKD.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc58xWKD.s:12     .text.sync_recv:0000000000000000 sync_recv
     /tmp/cc58xWKD.s:49     .text.sync_send:0000000000000000 sync_send
     /tmp/cc58xWKD.s:88     .text.serial_read_chunk:0000000000000000 serial_read_chunk
     /tmp/cc58xWKD.s:209    .text.serial_recive_packet:0000000000000000 serial_recive_packet
     /tmp/cc58xWKD.s:306    .text.soft_serial_initiator_init:0000000000000000 soft_serial_initiator_init
     /tmp/cc58xWKD.s:1232   .bss.Transaction_table:0000000000000000 Transaction_table
     /tmp/cc58xWKD.s:1227   .bss.Transaction_table_size:0000000000000000 Transaction_table_size
     /tmp/cc58xWKD.s:339    .text.soft_serial_target_init:0000000000000000 soft_serial_target_init
     /tmp/cc58xWKD.s:377    .text.serial_write_chunk:0000000000000000 serial_write_chunk
     /tmp/cc58xWKD.s:486    .text.serial_send_packet:0000000000000000 serial_send_packet
     /tmp/cc58xWKD.s:559    .text.__vector_3:0000000000000000 __vector_3
     /tmp/cc58xWKD.s:862    .text.soft_serial_transaction:0000000000000000 soft_serial_transaction
     /tmp/cc58xWKD.s:1174   .text.soft_serial_get_and_clean_status:0000000000000000 soft_serial_get_and_clean_status

UNDEFINED SYMBOLS
__do_clear_bss
